<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>STELLAR BLASTER</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Share+Tech+Mono&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: #000;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    overflow: hidden;
    font-family: 'Share Tech Mono', monospace;
    touch-action: none;
  }

  #wrapper {
    position: relative;
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  #hud {
    width: 100%;
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 6px 10px;
    background: rgba(0,0,0,0.8);
    border-bottom: 1px solid #00ffff44;
  }

  .hud-item {
    font-family: 'Orbitron', sans-serif;
    font-size: 12px;
    color: #00ffcc;
    text-shadow: 0 0 8px #00ffcc;
    letter-spacing: 1px;
  }

  .hud-val {
    font-size: 16px;
    font-weight: 700;
    color: #fff;
    text-shadow: 0 0 10px #00ffff;
  }

  #lives-display { color: #ff4466; text-shadow: 0 0 8px #ff4466; font-size: 18px; }

  canvas {
    display: block;
    background: #000;
    cursor: none;
  }

  #overlay {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: rgba(0,0,8,0.92);
    z-index: 10;
  }

  #overlay h1 {
    font-family: 'Orbitron', sans-serif;
    font-size: clamp(24px, 8vw, 52px);
    font-weight: 900;
    color: #00ffff;
    text-shadow: 0 0 20px #00ffff, 0 0 40px #0088ff;
    letter-spacing: 4px;
    margin-bottom: 8px;
    animation: pulse 2s ease-in-out infinite;
  }

  #overlay .subtitle {
    font-size: clamp(10px, 3vw, 14px);
    color: #00ffcc88;
    letter-spacing: 6px;
    margin-bottom: 30px;
  }

  #overlay .score-display {
    font-family: 'Orbitron', sans-serif;
    font-size: clamp(14px, 4vw, 22px);
    color: #ffcc00;
    text-shadow: 0 0 10px #ffcc00;
    margin-bottom: 6px;
  }

  #overlay .hi-display {
    font-size: clamp(10px, 3vw, 14px);
    color: #ff6688;
    text-shadow: 0 0 8px #ff6688;
    margin-bottom: 30px;
  }

  #startBtn {
    font-family: 'Orbitron', sans-serif;
    font-size: clamp(12px, 3.5vw, 16px);
    font-weight: 700;
    color: #000;
    background: linear-gradient(135deg, #00ffcc, #0088ff);
    border: none;
    padding: 14px 40px;
    letter-spacing: 3px;
    cursor: pointer;
    clip-path: polygon(8px 0%, 100% 0%, calc(100% - 8px) 100%, 0% 100%);
    transition: transform 0.15s, box-shadow 0.15s;
    box-shadow: 0 0 20px #00ffcc88;
  }

  #startBtn:hover, #startBtn:active {
    transform: scale(1.06);
    box-shadow: 0 0 35px #00ffcccc;
  }

  #controls {
    position: absolute;
    bottom: 0;
    width: 100%;
    height: 100px;
    display: none;
    align-items: center;
    justify-content: space-between;
    padding: 10px 20px;
    pointer-events: none;
    z-index: 5;
  }

  .ctrl-btn {
    width: 70px;
    height: 70px;
    border-radius: 50%;
    border: 2px solid #00ffcc66;
    background: rgba(0,255,204,0.08);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 24px;
    color: #00ffcc;
    pointer-events: all;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
    transition: background 0.1s;
    backdrop-filter: blur(4px);
  }

  .ctrl-btn:active { background: rgba(0,255,204,0.25); }

  #shoot-btn {
    width: 75px;
    height: 75px;
    border-radius: 50%;
    background: radial-gradient(circle, #ff446688, #ff224444);
    border: 2px solid #ff4466aa;
    font-size: 20px;
    box-shadow: 0 0 15px #ff446644;
  }

  #shoot-btn:active { background: radial-gradient(circle, #ff4466cc, #ff2244aa); }

  @keyframes pulse {
    0%, 100% { text-shadow: 0 0 20px #00ffff, 0 0 40px #0088ff; }
    50% { text-shadow: 0 0 30px #00ffff, 0 0 60px #0088ff, 0 0 80px #00ffff88; }
  }
</style>
</head>
<body>

<div id="wrapper">
  <div id="hud">
    <div class="hud-item">SCORE<br><span class="hud-val" id="scoreVal">0</span></div>
    <div class="hud-item" style="text-align:center;">LEVEL<br><span class="hud-val" id="levelVal">1</span></div>
    <div class="hud-item" style="text-align:right;">LIVES<br><span id="lives-display" id="livesVal">â™¥â™¥â™¥</span></div>
  </div>
  <canvas id="c"></canvas>
  <div id="controls">
    <div style="display:flex;gap:10px;">
      <div class="ctrl-btn" id="btnL">â—€</div>
      <div class="ctrl-btn" id="btnR">â–¶</div>
    </div>
    <div class="ctrl-btn" id="shoot-btn">ðŸ”¥</div>
  </div>
  <div id="overlay">
    <h1>STELLAR</h1>
    <div class="subtitle">B L A S T E R</div>
    <div class="score-display" id="finalScore" style="display:none"></div>
    <div class="hi-display" id="hiScore"></div>
    <button id="startBtn" onclick="startGame()">LAUNCH</button>
  </div>
</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const overlay = document.getElementById('overlay');
const scoreValEl = document.getElementById('scoreVal');
const levelValEl = document.getElementById('levelVal');
const livesEl = document.getElementById('lives-display');
const controlsEl = document.getElementById('controls');

// Responsive sizing
function resize() {
  const maxW = Math.min(window.innerWidth, 480);
  const maxH = window.innerHeight - 44 - (isMobile ? 100 : 0);
  const ratio = 9/16;
  let w = maxW, h = w / ratio;
  if (h > maxH) { h = maxH; w = h * ratio; }
  canvas.width = Math.floor(w);
  canvas.height = Math.floor(h);
  document.getElementById('wrapper').style.width = canvas.width + 'px';
  if (isMobile) {
    controlsEl.style.width = canvas.width + 'px';
  }
}

const isMobile = /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent) || window.innerWidth < 600;
if (isMobile) controlsEl.style.display = 'flex';

window.addEventListener('resize', () => { resize(); });
resize();

// â”€â”€â”€ Game State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let score = 0, lives = 3, level = 1, hiScore = 0;
let running = false, gameOver = false;
let enemyInterval, enemySpeed, shootCooldown = 0;
let frameId;

// Entities
let player, bullets, enemies, particles, stars, powerups, explosions;

function initGame() {
  score = 0; lives = 3; level = 1; gameOver = false;
  enemySpeed = 0.8; enemyInterval = 120; shootCooldown = 0;

  const W = canvas.width, H = canvas.height;
  player = { x: W/2, y: H - 70, w: 36, h: 36, speed: 5, invincible: 0, shootRate: 15 };
  bullets = []; enemies = []; particles = []; powerups = []; explosions = [];
  enemyTimer = 0;

  // Starfield
  stars = Array.from({length: 80}, () => ({
    x: Math.random() * W,
    y: Math.random() * H,
    r: Math.random() * 1.5 + 0.3,
    speed: Math.random() * 0.8 + 0.2,
    alpha: Math.random() * 0.7 + 0.3
  }));
  updateHUD();
}

let enemyTimer = 0;
const keys = {};

// â”€â”€â”€ Input â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
window.addEventListener('keydown', e => { keys[e.code] = true; if (['Space','ArrowUp','ArrowLeft','ArrowRight'].includes(e.code)) e.preventDefault(); });
window.addEventListener('keyup', e => { keys[e.code] = false; });

// Touch controls
let touchX = null, touchStartX = null;
canvas.addEventListener('touchstart', e => {
  touchStartX = e.touches[0].clientX;
  touchX = e.touches[0].clientX;
}, {passive: true});
canvas.addEventListener('touchmove', e => {
  touchX = e.touches[0].clientX;
}, {passive: true});
canvas.addEventListener('touchend', () => { touchX = null; touchStartX = null; }, {passive: true});

// Mobile buttons
let btnLeft = false, btnRight = false, btnShoot = false;
document.getElementById('btnL').addEventListener('touchstart', e => { btnLeft = true; e.preventDefault(); });
document.getElementById('btnL').addEventListener('touchend', () => { btnLeft = false; });
document.getElementById('btnR').addEventListener('touchstart', e => { btnRight = true; e.preventDefault(); });
document.getElementById('btnR').addEventListener('touchend', () => { btnRight = false; });
document.getElementById('shoot-btn').addEventListener('touchstart', e => { btnShoot = true; e.preventDefault(); });
document.getElementById('shoot-btn').addEventListener('touchend', () => { btnShoot = false; });

// â”€â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function rand(a, b) { return Math.random() * (b - a) + a; }
function randInt(a, b) { return Math.floor(rand(a, b+1)); }

function spawnParticles(x, y, color, count = 12) {
  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = rand(1, 5);
    particles.push({
      x, y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      r: rand(2, 5),
      alpha: 1,
      color,
      life: rand(20, 40)
    });
  }
}

function spawnEnemy() {
  const W = canvas.width;
  const types = ['basic', 'tank', 'speeder'];
  const weights = level < 3 ? [0.8, 0.1, 0.1] : level < 6 ? [0.5, 0.25, 0.25] : [0.3, 0.35, 0.35];
  let r = Math.random(), type = 'basic';
  if (r > weights[0] + weights[1]) type = 'speeder';
  else if (r > weights[0]) type = 'tank';

  const cfg = {
    basic:   { w: 32, h: 28, hp: 1, maxHp: 1,  score: 100, color: '#ff4466', spd: enemySpeed },
    tank:    { w: 40, h: 36, hp: 3, maxHp: 3,  score: 300, color: '#ff8800', spd: enemySpeed * 0.6 },
    speeder: { w: 24, h: 22, hp: 1, maxHp: 1,  score: 200, color: '#cc44ff', spd: enemySpeed * 1.8 },
  }[type];

  enemies.push({
    x: rand(cfg.w, W - cfg.w),
    y: -cfg.h,
    ...cfg, type,
    zigzag: type === 'speeder' ? rand(-1,1) : 0,
    zigTimer: 0,
    shootTimer: type === 'tank' ? randInt(60, 120) : 0,
  });
}

// â”€â”€â”€ Draw Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawPlayer(p) {
  const { x, y, w, h, invincible } = p;
  if (invincible > 0 && Math.floor(invincible / 5) % 2 === 0) return;
  ctx.save();
  ctx.translate(x, y);

  // Engine glow
  const engGlow = ctx.createRadialGradient(0, h*0.4, 1, 0, h*0.4, 18);
  engGlow.addColorStop(0, '#00ffcc');
  engGlow.addColorStop(1, 'transparent');
  ctx.fillStyle = engGlow;
  ctx.beginPath(); ctx.ellipse(0, h*0.35, 12, 20, 0, 0, Math.PI*2); ctx.fill();

  // Body
  ctx.fillStyle = '#0088ff';
  ctx.beginPath();
  ctx.moveTo(0, -h/2);
  ctx.lineTo(w/2, h/2);
  ctx.lineTo(w*0.2, h*0.3);
  ctx.lineTo(-w*0.2, h*0.3);
  ctx.lineTo(-w/2, h/2);
  ctx.closePath();
  ctx.fill();

  // Highlight
  const grad = ctx.createLinearGradient(-w/2, -h/2, w/2, h/2);
  grad.addColorStop(0, 'rgba(255,255,255,0.3)');
  grad.addColorStop(1, 'transparent');
  ctx.fillStyle = grad;
  ctx.fill();

  // Cockpit
  ctx.fillStyle = '#00ffff';
  ctx.beginPath();
  ctx.ellipse(0, -h*0.1, 7, 9, 0, 0, Math.PI*2);
  ctx.fill();

  ctx.restore();
}

function drawEnemy(e) {
  ctx.save();
  ctx.translate(e.x, e.y);
  if (e.type === 'basic') {
    ctx.fillStyle = e.color;
    ctx.beginPath();
    ctx.moveTo(0, e.h/2);
    ctx.lineTo(e.w/2, -e.h/2);
    ctx.lineTo(e.w*0.15, -e.h*0.15);
    ctx.lineTo(-e.w*0.15, -e.h*0.15);
    ctx.lineTo(-e.w/2, -e.h/2);
    ctx.closePath();
    ctx.fill();
    ctx.fillStyle = '#ff8899';
    ctx.beginPath(); ctx.ellipse(0, 0, 6, 5, 0, 0, Math.PI*2); ctx.fill();
  } else if (e.type === 'tank') {
    ctx.fillStyle = e.color;
    ctx.beginPath();
    ctx.roundRect(-e.w/2, -e.h/2, e.w, e.h, 6);
    ctx.fill();
    // HP bar
    const bw = e.w * 0.8, bx = -bw/2, by = -e.h/2 - 8;
    ctx.fillStyle = '#333'; ctx.fillRect(bx, by, bw, 5);
    ctx.fillStyle = '#ff8800';
    ctx.fillRect(bx, by, bw * (e.hp/e.maxHp), 5);
    ctx.fillStyle = '#ffaa44';
    ctx.beginPath(); ctx.ellipse(0, 0, 10, 8, 0, 0, Math.PI*2); ctx.fill();
  } else {
    ctx.fillStyle = e.color;
    ctx.beginPath();
    ctx.moveTo(0, e.h/2);
    ctx.lineTo(e.w*0.4, 0);
    ctx.lineTo(e.w/2, -e.h/2);
    ctx.lineTo(-e.w/2, -e.h/2);
    ctx.lineTo(-e.w*0.4, 0);
    ctx.closePath();
    ctx.fill();
    ctx.fillStyle = '#ee88ff';
    ctx.beginPath(); ctx.ellipse(0, 0, 5, 4, 0, 0, Math.PI*2); ctx.fill();
  }
  ctx.restore();
}

// â”€â”€â”€ Update â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function update() {
  const W = canvas.width, H = canvas.height;
  shootCooldown--;

  // Player movement
  let moveDir = 0;
  if (keys['ArrowLeft'] || keys['KeyA'] || btnLeft) moveDir = -1;
  if (keys['ArrowRight'] || keys['KeyD'] || btnRight) moveDir = 1;
  if (touchX !== null && touchStartX !== null) {
    const dx = touchX - touchStartX;
    if (Math.abs(dx) > 5) moveDir = dx > 0 ? 1 : -1;
  }
  player.x = Math.max(player.w/2, Math.min(W - player.w/2, player.x + moveDir * player.speed));

  // Shoot
  if ((keys['Space'] || keys['ArrowUp'] || btnShoot) && shootCooldown <= 0) {
    bullets.push({ x: player.x, y: player.y - player.h/2, vy: -10, r: 5, player: true });
    shootCooldown = player.shootRate;
  }

  // Enemy spawn
  enemyTimer++;
  const spawnRate = Math.max(30, enemyInterval - level * 8);
  if (enemyTimer >= spawnRate) { spawnEnemy(); enemyTimer = 0; }

  // Move bullets
  for (let i = bullets.length-1; i >= 0; i--) {
    const b = bullets[i];
    b.y += b.vy;
    if (b.y < -20 || b.y > H + 20) bullets.splice(i, 1);
  }

  // Move enemies & check
  player.invincible = Math.max(0, player.invincible - 1);
  for (let i = enemies.length-1; i >= 0; i--) {
    const e = enemies[i];
    e.y += e.spd;
    e.zigTimer++;
    if (e.type === 'speeder' && e.zigTimer % 40 === 0) e.zigzag = -e.zigzag;
    e.x += e.zigzag * 2;
    e.x = Math.max(e.w/2, Math.min(W - e.w/2, e.x));

    // Tank shoots
    if (e.type === 'tank') {
      e.shootTimer--;
      if (e.shootTimer <= 0) {
        bullets.push({ x: e.x, y: e.y + e.h/2, vy: 4, r: 5, player: false, color: '#ff8800' });
        e.shootTimer = randInt(60, 120);
      }
    }

    // Off screen
    if (e.y > H + e.h) {
      enemies.splice(i, 1);
      continue;
    }

    // Player collision
    if (player.invincible <= 0) {
      if (Math.abs(e.x - player.x) < (e.w/2 + player.w/2 - 4) &&
          Math.abs(e.y - player.y) < (e.h/2 + player.h/2 - 4)) {
        spawnParticles(player.x, player.y, '#00ffcc', 20);
        enemies.splice(i, 1);
        lives--;
        player.invincible = 120;
        updateHUD();
        if (lives <= 0) { endGame(); return; }
        continue;
      }
    }

    // Bullet collision
    for (let j = bullets.length-1; j >= 0; j--) {
      const b = bullets[j];
      if (!b.player) continue;
      if (Math.abs(b.x - e.x) < e.w/2 + b.r && Math.abs(b.y - e.y) < e.h/2 + b.r) {
        bullets.splice(j, 1);
        e.hp--;
        spawnParticles(b.x, b.y, e.color, 6);
        if (e.hp <= 0) {
          score += e.score * level;
          spawnParticles(e.x, e.y, e.color, 18);
          enemies.splice(i, 1);
          updateHUD();
          checkLevel();
        }
        break;
      }
    }
  }

  // Enemy bullets vs player
  if (player.invincible <= 0) {
    for (let j = bullets.length-1; j >= 0; j--) {
      const b = bullets[j];
      if (b.player) continue;
      if (Math.abs(b.x - player.x) < player.w/2 + b.r && Math.abs(b.y - player.y) < player.h/2 + b.r) {
        bullets.splice(j, 1);
        spawnParticles(player.x, player.y, '#00ffcc', 12);
        lives--;
        player.invincible = 120;
        updateHUD();
        if (lives <= 0) { endGame(); return; }
      }
    }
  }

  // Particles
  for (let i = particles.length-1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx; p.y += p.vy;
    p.vy += 0.1;
    p.life--;
    p.alpha = p.life / 40;
    if (p.life <= 0) particles.splice(i, 1);
  }

  // Stars
  for (const s of stars) {
    s.y += s.speed;
    if (s.y > H) { s.y = 0; s.x = Math.random() * W; }
  }
}

function checkLevel() {
  const newLevel = Math.floor(score / 2000) + 1;
  if (newLevel > level) {
    level = newLevel;
    enemySpeed = 0.8 + (level-1) * 0.2;
    levelValEl.textContent = level;
    // Flash level up
    spawnParticles(canvas.width/2, canvas.height/2, '#ffcc00', 30);
  }
}

// â”€â”€â”€ Draw â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function draw() {
  const W = canvas.width, H = canvas.height;
  ctx.clearRect(0, 0, W, H);

  // Background
  const bg = ctx.createLinearGradient(0,0,0,H);
  bg.addColorStop(0, '#000010');
  bg.addColorStop(1, '#000820');
  ctx.fillStyle = bg;
  ctx.fillRect(0,0,W,H);

  // Stars
  for (const s of stars) {
    ctx.save();
    ctx.globalAlpha = s.alpha;
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(s.x, s.y, s.r, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  // Enemy bullets
  for (const b of bullets) {
    if (b.player) continue;
    ctx.save();
    ctx.globalAlpha = 0.9;
    const g = ctx.createRadialGradient(b.x, b.y, 1, b.x, b.y, b.r*2);
    g.addColorStop(0, '#fff');
    g.addColorStop(1, b.color || '#ff8800');
    ctx.fillStyle = g;
    ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI*2); ctx.fill();
    ctx.restore();
  }

  // Player bullets
  for (const b of bullets) {
    if (!b.player) continue;
    ctx.save();
    // Glow trail
    ctx.shadowBlur = 12;
    ctx.shadowColor = '#00ffcc';
    const g = ctx.createRadialGradient(b.x, b.y, 1, b.x, b.y, b.r*2.5);
    g.addColorStop(0, '#ffffff');
    g.addColorStop(0.5, '#00ffcc');
    g.addColorStop(1, 'transparent');
    ctx.fillStyle = g;
    ctx.beginPath(); ctx.arc(b.x, b.y, b.r*2.5, 0, Math.PI*2); ctx.fill();
    ctx.restore();
  }

  // Enemies
  for (const e of enemies) drawEnemy(e);

  // Player
  drawPlayer(player);

  // Particles
  for (const p of particles) {
    ctx.save();
    ctx.globalAlpha = Math.max(0, p.alpha);
    ctx.fillStyle = p.color;
    ctx.shadowBlur = 8;
    ctx.shadowColor = p.color;
    ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2); ctx.fill();
    ctx.restore();
  }
}

// â”€â”€â”€ Loop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function loop() {
  if (!running) return;
  update();
  draw();
  frameId = requestAnimationFrame(loop);
}

function updateHUD() {
  scoreValEl.textContent = score.toLocaleString();
  levelValEl.textContent = level;
  livesEl.textContent = 'â™¥'.repeat(Math.max(0, lives));
}

function startGame() {
  overlay.style.display = 'none';
  initGame();
  running = true;
  loop();
}

function endGame() {
  running = false;
  cancelAnimationFrame(frameId);
  gameOver = true;
  if (score > hiScore) hiScore = score;

  document.getElementById('finalScore').style.display = 'block';
  document.getElementById('finalScore').textContent = 'SCORE  ' + score.toLocaleString();
  document.getElementById('hiScore').textContent = 'HI-SCORE  ' + hiScore.toLocaleString();
  document.querySelector('#overlay h1').textContent = 'GAME OVER';
  document.querySelector('.subtitle').textContent = 'T R Y  A G A I N';
  document.getElementById('startBtn').textContent = 'RETRY';
  overlay.style.display = 'flex';
}

// Init overlay hi score display
document.getElementById('hiScore').textContent = '';
</script>
</body>
</html>
